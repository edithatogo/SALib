# -*- coding: utf-8 -*-
"""
This module implements the sampling method for a correlation-aware Sobol
sensitivity analysis, based on constructing sample matrices A, B, C_i, and D_i
from base correlated samples.
"""
import numpy as np
from SALib.sample.latin import sample as latin_sample # For generating base correlated samples
from SALib.util importดูเพิ่มเติม
from SALib.sample.latin import sample as latin_sample # For generating base correlated samples
# (already present) from SALib.util import ProblemSpec # Not directly needed, problem is dict


def sample(problem: dict, N: int, calc_second_order: bool = True, seed: int = None) -> np.ndarray:
    """
    Generates samples for a correlation-aware Sobol sensitivity analysis method.

    This sampler produces the necessary input matrices for estimating "full"
    first-order, total-order, and second-order sensitivity indices when input
    parameters are correlated, consistent with methodologies like those discussed
    in Janon et al. (2013) and adaptations of Saltelli (2002) for such contexts.
    The sampling scheme generates N * (2 + 2*D) samples, where D is the
    number of parameters.

    It requires a `corr_matrix` to be defined in the `problem` dictionary.
    The base sample matrices (X_A and X_B) are generated using correlated
    Latin Hypercube Sampling (`SALib.sample.latin.sample`). Hybrid matrices
    (X_Ci and X_Di) are then constructed from X_A and X_B.

    Parameters
    ----------
    problem : dict
        The problem definition, including:
        - `num_vars` (int): Number of input variables.
        - `names` (list): List of variable names.
        - `bounds` (list): List of bounds for each variable.
        - `corr_matrix` (np.ndarray): The target rank correlation matrix.
        - `dists` (list, optional): List of marginal distributions for variables.
    N : int
        The base number of samples. The total number of samples generated
        will be N * (2 + 2 * D).
    calc_second_order : bool, optional
        This parameter is maintained for consistency with other Sobol samplers.
        The N*(2+2D) scheme is inherently capable of supporting second-order
        estimation if the analyzer implements it. Currently, this flag does
        not change the number of samples generated by this sampler.
        Default is True.
    seed : int, optional
        Seed for random number generation.

    Returns
    -------
    np.ndarray
        A NumPy array of samples, with shape (N * (2 + 2*D), D).
        The samples are ordered as: X_A, X_B, X_C1, ..., X_CD, X_D1, ..., X_DD.
    """
    if seed is not None:
        np.random.seed(seed)

    num_vars = problem['num_vars']

    if problem.get('corr_matrix') is None:
        raise ValueError("A `corr_matrix` must be defined in the problem dictionary "
                         "for `sample_sobol_correlated`.")

    # ProblemSpec validation for corr_matrix should have happened upstream if using ProblemSpec,
    # but a basic check for presence is good.
    # Further validation of corr_matrix (e.g. positive definite for Cholesky in latin_sample)
    # will be handled by the latin_sample call or ProblemSpec.

    if problem.get('groups') is not None:
        raise ValueError("The `sample_sobol_correlated` sampler does not support grouped parameters "
                         "when a `corr_matrix` is specified. Define correlations directly.")

    # Generate Base Correlated Samples X_A and X_B
    # Manage seeds for reproducibility and independence of A and B
    seed_A = None
    seed_B = None
    if seed is not None:
        # Derive distinct seeds for A and B from the main seed
        # Using simple addition might be okay for different np.random.seed calls,
        # but creating independent RandomState instances is more robust if available/easy.
        # For now, np.random.seed reinitializes the global state.
        # To ensure X_A and X_B are different if seed is provided,
        # we call latin_sample with derived seeds.
        # If latin_sample's seed arg is None, it does not re-seed globally.
        X_A_correlated = latin_sample(problem, N, seed=seed)
        X_B_correlated = latin_sample(problem, N, seed=seed + 1 if seed is not None else None)
    else: # No main seed provided
        X_A_correlated = latin_sample(problem, N, seed=None)
        X_B_correlated = latin_sample(problem, N, seed=None) # Should be independent


    # Construct Hybrid Matrices X_Ci and X_Di
    # X_Ci matrices: column i from X_A, other columns from X_B
    # X_Di matrices: column i from X_B, other columns from X_A

    # Pre-allocate arrays for all C_i and D_i matrices combined
    # Each individual C_i or D_i is NxD. There are D of C_i and D of D_i.
    # So N*D x D for all C_i, and N*D x D for all D_i.
    # This seems wrong. It should be D matrices, each NxD.
    # The final output is stacked.

    all_X_Ci = []
    all_X_Di = []

    for i in range(num_vars):
        X_Ci = np.copy(X_B_correlated)
        X_Ci[:, i] = X_A_correlated[:, i]
        all_X_Ci.append(X_Ci)

        X_Di = np.copy(X_A_correlated)
        X_Di[:, i] = X_B_correlated[:, i]
        all_X_Di.append(X_Di)

    # Concatenate all matrices: X_A, X_B, then all X_Ci, then all X_Di
    # (X_C1, X_C2, ..., X_CD), (X_D1, X_D2, ..., X_DD)

    # Correct way to stack:
    # X_A (N,D)
    # X_B (N,D)
    # X_C1 (N,D)
    # ...
    # X_CD (N,D)
    # X_D1 (N,D)
    # ...
    # X_DD (N,D)

    matrices_to_stack = [X_A_correlated, X_B_correlated]
    matrices_to_stack.extend(all_X_Ci)
    matrices_to_stack.extend(all_X_Di)

    final_samples = np.concatenate(matrices_to_stack, axis=0)

    # Expected shape: (N * (2 + 2*D), D)
    expected_rows = N * (2 + 2 * num_vars)
    if final_samples.shape[0] != expected_rows or final_samples.shape[1] != num_vars:
        # This should not happen if logic is correct
        raise RuntimeError(f"Internal error: Final sample matrix shape mismatch. "
                           f"Expected ({expected_rows}, {num_vars}), got {final_samples.shape}")

    return final_samples
